#include <iostream>
#include <cmath>

using namespace std;

/*
最大切分乘积问题
给定一个正整数 n , 将其切分为至少两个正整数的和, 求切分后所有整数的乘积最大是多少
*/

/*
假设将 n 切分为 m 个正整数因子, 其中第 i 个银子记为 n_i , 则 n = n_1 + n_2 + ... + n_m
目标时求得所有 n_i 的乘积最大, 记为 P = n_1 * n_2 * ... * n_m
需要思考的是: 切分数量 m 应该多大, 每个 n_i 应该取多少
*/

/*
贪心策略:
一般来说, 两个整数的乘积往往比这两个整数之和要大
假设 n 中分出一个因子 2, 则乘积 P = 2 * (n - 2) = 2 * n - 4
P > n  ->  2 * n - 4 > n  ->  n > 4
当 n > 4 时, 切分出一个因子 2, 乘积会变大, 说明大于等于 4 的整数都应该被切分
*/

/*
贪心策略一:
1. 如果切分方案中包含 >= 4 的因子, 那么它就应该被继续切分
2. 最终的切分方案只应该出现1, 2, 3 三种因子
3. 在1, 2, 3 这三个因子中, 显然 1 是最差的, 因为 1 * (n - 1) < n 恒成立, 即且分出 1 反而会导致乘积减小
*/

/*
贪心策略二:
1. 在切分方案中, 最多只应存在两个2
2. 因为三个2可以被替换为两个3, 2 * 2 * 2 < 3 * 3
3. 当 n = 6 时, 2 * 2 * 2 = 8, 3 * 3 = 9, 这意味着切分出 3 比切分出 2 更好
*/

/*
综上所述, 最终的贪心策略为:
1. 输入整数 n, 从其不断的切分出因子 3, 直到余数为 0 , 1, 2
2. 当余数为 0 时, 说明 n 是 3 的整数倍, 因此不做任何切分
3. 当余数为 1 时, 由于 2 * 2 > 3 * 1, 因此将最后一个 3 替换为 2 * 2
4. 当余数为 2 时, 不继续切分, 保留
*/

/* 最大切分乘积：贪心 */
int maxProductCutting(int n) {
    // 当 n <= 3 时，必须切分出一个 1
    if (n <= 3) {
        return 1 * (n - 1);
    }
    // 贪心地切分出 3 ，a 为 3 的个数，b 为余数
    int a = n / 3;
    int b = n % 3;
    if (b == 1) {
        // 当余数为 1 时，将一对 1 * 3 转化为 2 * 2
        return (int)pow(3, a - 1) * 2 * 2;
    }
    if (b == 2) {
        // 当余数为 2 时，不做处理
        return (int)pow(3, a) * 2;
    }
    // 当余数为 0 时，不做处理
    return (int)pow(3, a);
}

// 注意: pow(x, y) 函数意为: x 的 y 次方

int main() {
    int n = 10;
    cout << maxProductCutting(n) << endl;  // 36
    return 0;
}