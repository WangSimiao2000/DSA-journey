#include <iostream>
#include <vector>

using namespace std;

/*
最大容量问题:
输入一个数组 ht , 其中每个元素代表一个垂直隔板的高度
数组中任意两个隔板, 以及他们之间的空间可以组成一个容器
容器的容量等于高度和宽度的乘积(面积), 其中高度由较短的隔板决定, 宽度由等于两个隔板之间的数组索引之差
请在数组中选择两个隔板, 使得容器的容量最大, 并返回容器的容量
*/

/*
本题的状态为两个隔板的索引, 记为 [i, j]
根据题意, 容量等于高度和宽度的乘积, 其中高度由较短的隔板决定, 宽度由等于两个隔板之间的数组索引之差
设容量为 cap[i,j] , 可得计算公式:
cap[i, j] = min(ht[i], ht[j]) * (j - i)
设数组长度为 n, 两个隔板的组合数量(状态总数)为 C(n, 2) = n * (n-1) / 2 个, 最直接的, 可以穷举所有状态, 计算出最大容量, 时间复杂度为 O(n^2), 但是这种方法显然不是最优的
*/

/*
现选取一个状态 [i, j], 其中 i < j 且高度 ht[i] < ht[j], 即 i 为短板, j 为长板
若此时长板 j 向短板 i 靠近, 则容量一定变小, 因为移动长板 j 后, 宽度 j-i 一定变小, 而高度由短板 i 决定, 因此高度只可能不变(i 仍为短板)或变小(新的短板为 j)

只有向内收缩短板 i , 才有可能使得容量增大, 因为虽然宽度 j-i 变小, 但是高度由新的短板决定(移动后的短板 i 可能会变长), 移动短板后面积变大

贪心策略:
1. 初始状态下, 指针 i 和 j 分列数组两端
2. 计算当前状态的容量 cap[i,j] , 并更新最大容量
3. 比较板 i 和板 j 的高度, 并将短板向内移动一格
4. 循环执行步骤 2 和 3, 直到两指针相遇时结束
*/

/* 最大容量：贪心 */
int maxCapacity(vector<int> &ht) {
    // 初始化 i, j，使其分列数组两端
    int i = 0, j = ht.size() - 1;
    // 初始最大容量为 0
    int res = 0;
    // 循环贪心选择，直至两板相遇
    while (i < j) {
        // 更新最大容量
        int cap = min(ht[i], ht[j]) * (j - i);
        res = max(res, cap);
        // 向内移动短板
        if (ht[i] < ht[j]) {
            i++;
        } else {
            j--;
        }
    }
    return res;
}

int main() {
    vector<int> ht = {1, 8, 6, 2, 5, 4, 8, 3, 7};
    cout << maxCapacity(ht) << endl;
    return 0;
}